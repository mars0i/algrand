;;;; An implementation of the algorithm in Nie's proof of the 
;;;; Machine Existence (Kraft-Chaitin) theorem in his book.
(ns algrand.kraftchaitin
    (:require [clojure.pprint :as pp]
              [clojure.math.numeric-tower :as m]
              [clojure.string :as s]))

;;(clojure.pprint/cl-format true "0.~b\n" (read-string "2r101"))
;; Note that if you pass a non-integer to ~b, you get back a decimal
;; representation.

(defn interval-of
  "Return a pair specifying bounds [x,y) of the interval generated by
  binary string s.  String can be specifed with our without a decimal
  point, but it's assumed to represent a value in [0,1)."
  [bin-s]
  (let [s (last (s/split bin-s #"\.")) ; strip initial int and decimal point
        s-len (count s)]
    (if (zero? s-len) ; special case for "", i.e. "0."
      [0.0 1.0]
      (let [s-weight (m/expt 2.0 (- s-len))
            s-int (read-string (str "2r" s)) ; only ints--no fractions allowed
            left-bound (* s-int s-weight)
            right-bound (+ left-bound s-weight)]
        [left-bound right-bound]))))

;; Note that when r = length of z, that's the z we want.  This
;; function will skip past it and pull it back on the next iteration.
;; That very slight inefficiency makes the code simpler.
(defn max-shorter
  "Given a sequence of strings Rn-1 sorted by length, and a string size r,
  returns the largest string with size greater than or equal to r."
  [Rn-1 r]
  (loop [zs Rn-1]
    (cond (not (next zs))          (first zs) ; no more; use what we have
          (< r (count (fnext zs))) (first zs)
          :else                    (recur (next zs)))))

(defn make-w
  "Given a z string indicating an available interval for an input code w, 
  and a pad-len indicating how much longer the the desired w should be,
  return a string that begins with z and has pad-len zeros appended to it."
  [old-z pad-len]
  (apply str 
         old-z 
         (repeat pad-len \0))) ; returns z if pad-len is zero

(defn make-new-z
  "Given a z string indicating a formerly available interval and a pad-len 
  indicating the additional length of one of the replacement z's, return a 
  string that begins with z, ends with 1, and has pad-len - 1 zeros between
  them."
  [old-z pad-len]
  (if (< pad-len 1)
    (throw (Exception. (str "pad-len " pad-len " shouldn't be < 1.")))
    (str
      (apply str 
             old-z
             (repeat (dec pad-len) \0))
      \1)))

(defn make-zs
  [old-z max-pad-len]
  (map (fn [pad-len] (make-new-z old-z pad-len))
       (range 1 (inc max-pad-len))))

(defn next-R-stage
  [Rn-1 r]
  (let [z (max-shorter Rn-1 r)
        pad-len (- r (count z))
        w (make-w z pad-len) 
        new-zs (make-zs z pad-len)
        Rn (concat (remove (partial = z) Rn-1)
                   new-zs)]
    [w Rn]))

(defn requests-weight
  "Calculate the 'weight' of a set of requested lengths for prefix-free 
  input codes (Nies p. 86).  Each r in rs should be a non-negative
  integer.  The weight is the sum_r 2^-r .  The weight condition is
  the requirement that this sum be <= 1."
  [rs]
  (reduce 
    (fn [sum r] (+ sum (m/expt 2.0 (- r))))
    0 rs))

;; TODO: fix docstring
(defn R-stages
  "TODO.  Throws an exception if the weight condition is not satisfied."
  [rs]
  (let [weight (requests-weight rs)]
    (println "Weight:" weight) ; DEBUG
    (if (> weight 1) ; test that weight condition is satisfieed
      (throw (Exception. (str "Weight condition isn't satisfied: weight " weight " > 1.")))
      (reduce (fn [[ws Rns] r]
                  (let [[w Rn] (next-R-stage (first Rns) r)]
                    [(cons w ws) (cons Rn Rns)]))
              [nil ""]
              rs))))

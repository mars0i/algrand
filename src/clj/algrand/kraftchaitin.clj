;;; An implementation of the algorithm in proof of the Machine 
;;; Existence (Kraft-Chaitin, KC) theorem 2.2.17, pp. 88f in Andr√© Nies' 
;; *Comutability and Randomness*, Oxford University Press 2009.
;;
;; See docs/kraftchaitin.md for additional usage info.

(ns algrand.kraftchaitin
    (:require [clojure.pprint :as pp]
              [clojure.math.numeric-tower :as m]
              [clojure.string :as s]))

;; Note that when r = length of z, that's the z we want.  This
;; function will skip past it and pull it back on the next iteration.
;; That very slight inefficiency makes the code simpler.
(defn max-shorter
  "Given a sequence of strings Rn-1 sorted by length, and a string size r,
  returns the largest string with size greater than or equal to r."
  [Rn-1 r]
  (loop [zs Rn-1]
    (cond (not (next zs))          (first zs) ; no more; use what we have
          (< r (count (fnext zs))) (first zs)
          :else                    (recur (next zs)))))

(defn make-w
  "Given a z string indicating an available interval for an input code w, 
  and a pad-len indicating how much longer the the desired w should be,
  return a string that begins with z and has pad-len zeros appended to it."
  [old-z pad-len]
  (apply str 
         old-z 
         (repeat pad-len \0))) ; returns z if pad-len is zero

(defn make-new-z
  "Given a z string indicating a formerly available interval and a pad-len 
  indicating the additional length of one of the replacement z's, return a 
  string that begins with z, ends with 1, and has pad-len - 1 zeros between
  them."
  [old-z pad-len]
  (if (< pad-len 1)
    (throw (Exception. (str "pad-len " pad-len " shouldn't be < 1.")))
    (str
      (apply str 
             old-z
             (repeat (dec pad-len) \0))
      \1)))

(defn make-zs
  "Given a z string indicating a formerly available interval and a
  max-pad-len indicating the maximum additional length of the new
  substitute z's, return the newly constructed z's."
  [old-z max-pad-len]
  (map (fn [pad-len] (make-new-z old-z pad-len))
       (range 1 (inc max-pad-len))))

(defn next-w-and-Rn
  "Given a previou Rn i.e. Rn-1 containing strings that represent intervals 
  available for new prefix-free input codes and a requested lewngth of an 
  input code, returns a pair, whose first element is a newly construct input 
  code w and whose second element is a new Rn containing strings
  representing available intervals for later input codes.  The length of a 
  string in Rn represents the width of the interval, which is 2^-length."
  [Rn-1 r]
  (let [z (max-shorter Rn-1 r)
        pad-len (- r (count z))
        w (make-w z pad-len) 
        new-zs (make-zs z pad-len)
        Rn (concat (remove (partial = z) Rn-1)
                   new-zs)]
    [w Rn]))

(defn requests-weight
  "Calculate the 'weight' of a set of requested lengths for prefix-free input
  codes.  Each r in rs should be a non-negative integer.  The weight is 
  sum_r 2^-r.  The weight condition is the requirement that this sum be <= 1."
  [rs]
  (reduce 
    (fn [sum r] (+ sum (m/expt 2.0 (- r))))
    0 rs))

(defn ws-and-Rns
  "Given a list of requested lengths for prefix-free input codes, generates a 
  sequence of those codes, paired with a sequence of Rn's containing strings
  that represent intervals that are available for new input codes.  The
  binary strings are digits after the decimal point reresenting the lower end
  of the interval (inclusive).  The length of a string in an Rn
  represents the width of the interval, which is 2^-length.  Throws an 
  exception if the weight condition is not satisfied."
  [rs]
  (let [weight (requests-weight rs)]
    (println "Weight:" weight) ; DEBUG
    (if (> weight 1) ; test that weight condition is satisfieed
      (throw (Exception. (str "Weight condition isn't satisfied: weight " weight " > 1.")))
      (reduce (fn [[ws Rns] r]
                  (let [[w Rn] (next-w-and-Rn (first Rns) r)]
                    [(cons w ws) (cons Rn Rns)]))
              [nil ""]
              rs))))

(defn interval-of
  "Return a pair specifying bounds [x,y) of the interval generated by
  binary string s.  String can be specifed with our without a decimal
  point, but it's assumed to represent a value in [0,1)."
  [bin-s]
  (let [s (last (s/split bin-s #"\.")) ; strip initial int and decimal point
        s-len (count s)]
    (if (zero? s-len) ; special case for "", i.e. "0."
      [0.0 1.0]
      (let [s-weight (m/expt 2.0 (- s-len))
            s-int (read-string (str "2r" s)) ; only ints--no fractions allowed
            left-bound (* s-int s-weight)
            right-bound (+ left-bound s-weight)]
        [left-bound right-bound]))))

(defn fract-to-bin-str
  [x]
  (apply str
     (loop [y x, i -0, bits []]
       (let [dif (- y (m/expt 2.0 i))]
         (cond (zero? dif) bits
               (neg?  dif) (recur dif (dec i) (conj bits 0))
               (pos?  dif) (recur dif (dec i) (conj bits 1)))))))

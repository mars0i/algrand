;;;; An implementation of the algorithm in Nie's proof of the 
;;;; Machine Existence (Kraft-Chaitin) theorem in his book.
(ns algrand.kraftchaitin
    (:require [clojure.pprint :as pp]
              [clojure.math.numeric-tower :as m]
              [clojure.string :as s]))

;;(clojure.pprint/cl-format true "0.~b\n" (read-string "2r101"))
;; Note that if you pass a non-integer to ~b, you get back a decimal
;; representation.

(defn interval-of
  "Return a pair specifying bounds [x,y) of the interval generated by
  binary string s.  String can be specifed with our without a decimal
  point, but it's assumed to represent a value in [0,1)."
  [bin-s]
  (let [s (last (s/split bin-s #"\.")) ; strip initial int and decimal point
        s-len (count s)]
    (if (zero? s-len) ; special case for "", i.e. "0."
      [0.0 1.0]
      (let [s-weight (m/expt 2.0 (- s-len))
            s-int (read-string (str "2r" s)) ; only ints--no fractions allowed
            left-bound (* s-int s-weight)
            right-bound (+ left-bound s-weight)]
        [left-bound right-bound]))))

;; Note that when r = length of z, that's the z we want.  This
;; function will skip past it and pull it back on the next iteration.
;; That very slight inefficiency makes the code simpler.
(defn max-shorter
  "Given a sequence of strings Rn-1 sorted by length, and a string size r,
  returns the largest string with size greater than or equal to r."
  [Rn-1 r]
  (loop [zs Rn-1]
    (cond (not (next zs)) (first zs)
          (< r (count (fnext zs))) (first zs)
          :else 
          (recur (next zs)))))

(defn make-w
  [old-z pad-len]
  (apply str 
         old-z 
         (repeat pad-len \0))) ; returns z if pad-len is zero

(defn make-new-z
  [old-z pad-len]
  (if (< pad-len 1)
    nil ; this shouldn't happen
    (str
      (apply str 
             old-z
             (repeat (dec pad-len) \0))
      \1)))

(defn make-zs
  [old-z max-pad-len]
  (map (fn [pad-len] (make-new-z old-z pad-len))
       (range 1 (inc max-pad-len))))

(defn next-R-stage
  [Rn-1 r]
  (let [z (max-shorter Rn-1 r)
        pad-len (- r (count z))
        w (make-w z pad-len) 
        new-zs (make-zs z pad-len)
        Rn (concat (remove (partial = z) Rn-1)
                   (new-zs))]
    [w Rn]))

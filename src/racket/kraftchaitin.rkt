#lang racket


;; convenience abbreviation
(define (number->bin-string x)
  (~r x #:base 2))

;; Toggle between printing numbers in binary and decimal format
(define (toggle-print)
  (if (equal? base-print (current-print))
    (current-print binary-print)
    (current-print base-print)))

(define base-print (current-print))

;; Based on code by Leif Andersen at
;; https://stackoverflow.com/a/59847051/1455243
;; But it won't recurse into structures.
(define (binary-print val)
  (if (number? val)
      (display (number->bin-string val))
      (base-print val)))

(define (non-binary-string? s)
  (memf 
    (Î» (c) (not (or (eq? c #\0) (eq? c #\1))))
    (string->list s)))

;; Display a pair specifying bounds [x,y) of the Nies interval generated by
;; binary string s, e.g. "0110" for #b.0110; then return the pair as a list.
(define (interval-of bin-string)
  (if (non-binary-string? bin-string)
    (display (string-append "\"" bin-string "\"" " contains characters other than #\\0 and #\\1."))
    (let* ([len (string-length bin-string)]
	   [left-bound (if (zero? len)  ; empty string is special case
			 #b0.0
			 (string->number (string-append "#b." bin-string)))]
	   [right-bound (if (zero? len)
			  #b1.0 
			  (+ left-bound (expt 2.0 (- len))))])
      (display (string-append "["
			      (number->bin-string left-bound)
			      " "
			      (number->bin-string right-bound)
			      ")\n" ))
      (list left-bound right-bound))))

(define (fract-to-bin-str x)
  (if (zero? x)
    "0"
    (list->string (reverse (ftbs-aux x -1 '())))))

(define (ftbs-aux x i bits)
  (let ([dif (- x (expt 2.0 i))])
    (cond [(zero? dif) (cons #\1 bits)]
	  [(negative? dif) (ftbs-aux x   (- i 1) (cons #\0 bits))]
	  [(positive? dif) (ftbs-aux dif (- i 1) (cons #\1 bits))])))

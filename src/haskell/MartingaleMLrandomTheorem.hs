import Data.List  (union, transpose) -- no longer used: isPrefixOf
import Debug.Trace (trace)    -- DEBUG
import Data.Typeable (typeOf) -- DEBUG
import qualified Data.Tree  -- so I can convert to these trees and use some of their functions
-- import Data.Foldable (foldr', foldl')
-- import Data.Char  (digitToInt)


{-

Code to help verify/understand part of the second half of
Downey and Hirschfeldt's (2010) Theorem 6.3.4, p. 236, which is their
version of Schnorr's theorem that Martin-Löf randomness is equivalent
to randomness defined by computably enumerable martingales.  In
particular, a set of infinite sequences is Martin-Löf iff it contains
no sequences such thagt a c.e. martingale would produce infinite
profit betting on subsequent digits of such a sequence.

In particular, in the M-L random -> martingale random direction of the
proof, D&H give a method for constructing a martingale for each set in
an M-L test.  The construction starts from the fact (Proposition 2.19.2,
p. 74) that every computably enumerable set of infinite sequences can be
generated by a computably enumerable prefix-free set of finite
sequences, and then the construction specifies how to define a
martingale function d_n for each prefix-free set R_n generating one of
the sets U_n that is part of a given M-L test.

The code below constructs the values of d_n for a given R_n.  D&H's
description of d_n is terse, and I had trouble working out why d_n
really is a martingale.  This code allows me to perform the
construction, see the result, and better understand why it creates a
martingale.

(This is my first recent Haskell experiment.  No doubt it could much
more succinct and elegant.)

-}


-- TODO: maybe actually define the d functions so that they can be applied to inputs.


------------------------------------------------------------------
-- Basic definitions and functions


-- a should be Float; it's the payout
data Tree a = Leaf | Node {payout :: a,
                           nextZero :: (Tree a),
                           nextOne :: (Tree a)}
                           deriving (Show, Eq)  

instance Functor Tree where  
    fmap f Leaf = Leaf -- probably unused
    fmap f (Node p next0 next1) = Node (f p) (fmap f next0) (fmap f next1)

{- |
'copyTree tree' generates a new copy of tree.
-}
copyTree Leaf = Leaf
copyTree (Node p z o) = Node p (copyTree z) (copyTree o)

{- |
'truncateTree n tree' returns a tree that is identical tree up to
depth n, where it is truncated by replacing Nodes with Leafs.
-}
truncateTree _ Leaf = Leaf
truncateTree n (Node p z o) =
    if n <= 0
       then Leaf
       else Node p (truncateTree (n-1) z) (truncateTree (n-1) z)

{- |
'boundedTreeEqual n tree1 tree2' tests whether the two trees are
identical up to depth n.
-}
-- This is a lot faster than using truncateTree.
boundedTreeEqual :: (Integral a) => a -> Tree Double -> Tree Double -> Bool
boundedTreeEqual _ Leaf Leaf = True
boundedTreeEqual _ Leaf _    = False
boundedTreeEqual _ _ Leaf    = False
boundedTreeEqual n (Node p1 z1 o1) (Node p2 z2 o2) =
    if n <= 0
       then p1 == p2
       else (boundedTreeEqual (n-1) z1 z2) && (boundedTreeEqual (n-1) o1 o2)

-- not test data; these are essential
zeroPayoutsTree :: Tree Double
zeroPayoutsTree = Node 0.0 (zeroPayoutsTree) (zeroPayoutsTree)

onePayoutsTree  :: Tree Double
onePayoutsTree  = Node 1.0 (onePayoutsTree) (onePayoutsTree)


{- |
'lowerPayouts len' returns a list of payout components for a generator of 
length len.  The first element corresponds to the empty string; the last 
corresponds to the position one less than the length of the generator.  
These are payouts correspondng to the string up to that point.
-}
lowerPayouts :: Int -> [Double]
lowerPayouts len = map (2^^) [-len .. -1] -- from D&H: map ((2**) . (-len_s +)) [0 .. len_s-1]

-- FIXME This algorithm seems to be wrong; I don't think it captures D&H's
-- intention.  It doesn't even produce a Martingale for a single generator
-- string.  Typically, the next payouts are both equal, and both twice
-- the previous payout, so that E(X_i) = 4 X_{i-1}.  (!)  Maybe what I intended
-- was that only of those get a payout, so it's an off-by-one error.

-- Bad behavior notes:
--   Input '1' is processed only once.
--   Input '0' is always processed *and applies to both branches*
--   You get an infinite tree even if the initial tree arg is finite, 
--     because the default "" [] case returns onePayoutsTree.
--   But if the function is modified so that the default "" [] case returns 
--     a terminal node, then '1' is processed the appropriate number of times.

{- 
Is this what is happening?:
Even if the initial tree arg is truncated, 
if you try to go down the '1' branch, before that, next0 appears, and that
... what? will end up in onePayoutsTree?  How?  How do the first two
args ever get eaten in that case.
But you never go further down the '1' branch.  And in what gets
returned, that was never processed, is just what was in onePayoutsTree??
What I'm saying does not make sense.

Consider modifying to construct the infinite tree rather than depending
on zeroPayoutsTree and onePayoutsTree.
-} 


{- |
Add payouts for generator string with lower payouts to tree.  The first payout
corresponds to the empty string.
Example: addPayouts generator (lowerPayouts (length generator)) zeroPayoutsTree
-}
addPayouts (g:gs) (p:ps) (Node x next0 next1)
  | g == '0' = trace ("\ng: "++show g++" gs: "++show gs++"\np: "++show p++" ps: "++show ps++"\nnode now: "++show x++"\n") -- DEBUG
                     (Node (x+p) (addPayouts gs ps next0) next1)
  | g == '1' = trace ("\ng: "++show g++" gs: "++show gs++"\np: "++show p++" ps: "++show ps++"\nnode now: "++show x++"\n") -- DEBUG
                     (Node (x+p) next0 (addPayouts gs ps next1)) -- FIXME this line of code is ending the recursion. Because it's 2nd. Why?
  | otherwise = undefined
addPayouts ""  [] (Node _ _ _) = trace "empty args" onePayoutsTree -- once generator exhausted, rest are ones
-- addPayouts ""  [] (Node _ _ _) = trace "empty args" (Node (-1000) Leaf Leaf) -- DEBUG
addPayouts (g:gs) [] (Node _ _ _) = trace "empty payout list" undefined   -- shouldn't happen
addPayouts "" (p:ps) (Node _ _ _) = trace "empty data string" undefined   -- shouldn't happen
addPayouts _    _    Leaf = trace "default case" Leaf      -- probably shouldn't happen
--       trace ("\ng: "++show g++" gs: "++show gs++"\np: "++show p++" ps: "++show ps++"\nnode now: "++show x++"\n") -- DEBUG

-- MWE - THIS WORKS!  Why??
foo (g:gs) (Node x next0 next1)
  | g == '0' = trace "\n|0|\n" (Node (x+1) (foo gs next0) next1)
  | g == '1' = trace "\n|1|\n" (Node (x+1) next0 (foo gs next1))
  | otherwise = undefined
foo _ node = Node 42 Leaf Leaf


{- | Convenience function to addPayouts to a tree directly from a generator -}
addGeneratorPayouts tree generator =
    addPayouts generator (lowerPayouts (length generator)) tree
        
{- | Sum payouts from all generators in list generators. See addPayouts. -}
sumGeneratorSet generators =
    foldl addGeneratorPayouts zeroPayoutsTree generators
-- to use foldl vs foldr, swap order of args for addGeneratorPayouts

{- | Transform each generator set in a list into a test tree. See addPayouts. -}
makeMLtest :: [[String]] -> [Tree Double]
makeMLtest generator_set_list = map sumGeneratorSet generator_set_list

{- | 
Tests whether node satisfies the martingale property, assigning equal 
probability to each branch.  In other words, is the simple average of the 
two child payouts equal to the parent payout for each (non-Leaf) node?
-}
isMartingaleNode (Node p (Node zp _ _) (Node op _ _)) = (zp + op)/2 == p
isMartingaleNode (Node _ Leaf Leaf) = True -- OK for a truncated tree
isMartingaleNode _ = False -- unbalanced (?)

{- | 
Tests whether a tree satisfies the martingale property, assigning equal 
probability to each branch. In other words, is the simple average of the 
two child payouts always equal to the parent payout for each non-Leaf node?
(This obviously won't work with infinite trees.)
-}
isMartingaleTree top@(Node _ z o) =
    isMartingaleNode top && isMartingaleNode z && isMartingaleNode o

----------------------------------------------------------
-- Borrow tools from Data.Tree
-- I don't want that representation, but by converting to it, we get access
-- to one more more useful functions.

{- | Convert our Tree to Data.Tree -}
toDataTree Leaf = Data.Tree.Node (-42.0) []  -- Have to have a label, even for a leaf node
toDataTree (Node p next0 next1) =
    Data.Tree.Node p [toDataTree next0, toDataTree next1]

{- | Draw an ASCII diagram of a tree using Data.Tree.drawTree, other functions. -}
drawTree tree = putStr $ Data.Tree.drawTree $ fmap show (toDataTree tree)

----------------------------------------------------------
-- Convenience functions for constructing M-L tests

consOtherDigit initstr [] = initstr
consOtherDigit _ (s:ss) =
    if s == '1'
       then '0':s:ss
       else '1':s:ss

combineMLtests (x:xs) (y:ys) = (union x y) : combineMLtests xs ys
combineMLtests xs []         = xs
combineMLtests [] ys         = ys

--------------------------------------------------
-- Example M-L tests

-- prefix-free generators for M-L tests for infinite zeros and infinite ones
zeros          = iterate (\ss -> map ('0':) ss) [""] -- 0, 00, 000, ...
ones           = iterate (\ss -> map ('1':) ss) [""] -- 1, 11, 111, ...
terminal_zeros = [""] : iterate (\ss -> map ('1':) ss) ["0"] -- 0, 10, 110, ...
terminal_ones  = [""] : iterate (\ss -> map ('0':) ss) ["1"] -- 1, 01, 001, ... 

zero_ones = iterate (\ss -> map (consOtherDigit "0") ss) [""]
one_zeros = iterate (\ss -> map (consOtherDigit "1") ss) [""]
alternators = combineMLtests zero_ones one_zeros

zeros_or_ones = combineMLtests zeros ones
terminal_both = combineMLtests terminal_zeros terminal_ones

-- remove the first set since it includes "", a prefix to other elements
multisize :: [[String]]
multisize = drop 1 (foldr combineMLtests [[]] 
                          [terminal_ones, drop 2 terminal_zeros, 
                          drop 4 terminal_ones, drop 6 zeros])

-- Note that even though there are shared prefixes, no string in any
-- generator set is a prefix of any other (since they're all the same
-- length!).
someofem = foldr combineMLtests [[]] 
                 [zeros, ones, terminal_zeros, terminal_ones, zero_ones, 
                 one_zeros]
-- don't include e.g. multisize--you'll get prefix relations



{-
-- some test data
gen1 = "101110110"
gen2 = "1001001010101"
gp1 = addPayouts gen1 (lowerPayouts (length gen1)) zeroPayoutsTree
gp2 = addPayouts gen2 (lowerPayouts (length gen2)) gp1
g2s = sumGeneratorSet [gen1,gen2]
-}

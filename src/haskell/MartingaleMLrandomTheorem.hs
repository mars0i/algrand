import Data.List  (union, transpose) -- no longer used: isPrefixOf
import Debug.Trace (trace)    -- DEBUG
import Data.Typeable (typeOf) -- DEBUG
-- import Data.Foldable (foldr', foldl')
-- import Data.Char  (digitToInt)


{-

Code to help verify/understand part of the second half of
Downey and Hirschfeldt's (2010) Theorem 6.3.4, p. 236, which is their
version of Schnorr's theorem that Martin-Löf randomness is equivalent
to randomness defined by computably enumerable martingales.  In
particular, a set of infinite sequences is Martin-Löf iff it contains
no sequences such thagt a c.e. martingale would produce infinite
profit betting on subsequent digits of such a sequence.

In particular, in the M-L random -> martingale random direction of the
proof, D&H give a method for constructing a martingale for each set in
an M-L test.  The construction starts from the fact (Proposition 2.19.2,
p. 74) that every computably enumerable set of infinite sequences can be
generated by a computably enumerable prefix-free set of finite
sequences, and then the construction specifies how to define a
martingale function d_n for each prefix-free set R_n generating one of
the sets U_n that is part of a given M-L test.

The code below constructs the values of d_n for a given R_n.  D&H's
description of d_n is terse, and I had trouble working out why d_n
really is a martingale.  This code allows me to perform the
construction, see the result, and better understand why it creates a
martingale.

(This is my first recent Haskell experiment.  No doubt it could much
more succinct and elegant.)

-}


-- TODO: maybe actually define the d functions so that they can be applied to inputs.


------------------------------------------------------------------
-- Basic definitions and functions


-- a should be Float; it's the payout
data Tree a = Leaf | Node {payout :: a,
                           nextZero :: (Tree a),
                           nextOne :: (Tree a)}
                           deriving (Show, Eq)  

instance Functor Tree where  
    fmap f Leaf = Leaf -- probably unused
    fmap f (Node p next_zero next_one) = Node (f p) (fmap f next_zero) (fmap f next_one)

{- |
'copyTree tree' generates a new copy of tree.
-}
copyTree Leaf = Leaf
copyTree (Node p z o) = Node p (copyTree z) (copyTree o)

{- |
'truncateTree n tree' returns a tree that is identical tree up to
depth n, where it is truncated by replacing Nodes with Leafs.
-}
truncateTree _ Leaf = Leaf
truncateTree n (Node p z o) =
    if n <= 0
       then Leaf
       else Node p (truncateTree (n-1) z) (truncateTree (n-1) z)

{- |
'boundedTreeEqual n tree1 tree2' tests whether the two trees are
identical up to depth n.
-}
-- This is a lot faster than using truncateTree.
boundedTreeEqual :: (Integral a) => a -> Tree Double -> Tree Double -> Bool
boundedTreeEqual _ Leaf Leaf = True
boundedTreeEqual _ Leaf _    = False
boundedTreeEqual _ _ Leaf    = False
boundedTreeEqual n (Node p1 z1 o1) (Node p2 z2 o2) =
    if n <= 0
       then p1 == p2
       else (boundedTreeEqual (n-1) z1 z2) && (boundedTreeEqual (n-1) o1 o2)

-- some test data
gen1 = "101110110"
gen2 = "1001001010101"
gp1 = addPayouts gen1 (lowerPayouts (length gen1)) zeroPayoutsTree
gp2 = addPayouts gen2 (lowerPayouts (length gen2)) gp1
g2s = sumGeneratorSet [gen1,gen2]
    

-- not test data; these are essential
zeroPayoutsTree :: Tree Double
zeroPayoutsTree = Node 0.0 (zeroPayoutsTree) (zeroPayoutsTree)

onePayoutsTree  :: Tree Double
onePayoutsTree  = Node 1.0 (onePayoutsTree) (onePayoutsTree)


{- |
'lowerPayouts len' returns a list of payout components for a generator of 
length len.  The first element corresponds to the empty string; the last 
corresponds to the position one less than the length of the generator.  
These are payouts correspondng to the string up to that point.
-}
lowerPayouts :: Int -> [Double]
lowerPayouts len = map (2^^) [-len .. -1] -- from D&H: map ((2**) . (-len_s +)) [0 .. len_s-1]

{- |
Add payouts for generator string with lower payouts to tree.
Example: addPayouts generator (lowerPayouts (length generator)) zeroPayoutsTree
-}
addPayouts (g:gs) (p:ps) (Node x next_zero next_one)
    | g == '0' = Node (x+p) (addPayouts gs ps next_zero) next_one
    | g == '1' = Node (x+p) next_zero (addPayouts gs ps next_one)
addPayouts ""  [] (Node _ _ _) = onePayoutsTree -- once generator exhausted, rest are ones
addPayouts (g:gs) [] (Node _ _ _) = undefined   -- shouldn't happen
addPayouts "" (p:ps) (Node _ _ _) = undefined   -- shouldn't happen
addPayouts _    _    Leaf = Leaf      -- probably shouldn't happen

{- | Convenience function to addPayouts to a tree directly from a generator -}
addGeneratorPayouts tree generator =
    addPayouts generator (lowerPayouts (length generator)) tree
        
{- | Sum payouts from all generators in list generators. -}
sumGeneratorSet generators =
    foldl addGeneratorPayouts zeroPayoutsTree generators
-- to use foldl vs foldr, swap order of args for addGeneratorPayouts


----------------------------------------------------------
-- Convenience functions for constructing M-L tests

consOtherDigit initstr [] = initstr
consOtherDigit _ (s:ss) =
    if s == '1'
       then '0':s:ss
       else '1':s:ss

combineMLtests (x:xs) (y:ys) = (union x y) : combineMLtests xs ys
combineMLtests xs []         = xs
combineMLtests [] ys         = ys

--------------------------------------------------
-- Example M-L tests

-- prefix-free generators for M-L tests for infinite zeros and infinite ones
zeros          = iterate (\ss -> map ('0':) ss) [""] -- 0, 00, 000, ...
ones           = iterate (\ss -> map ('1':) ss) [""] -- 1, 11, 111, ...
terminal_zeros = [""] : iterate (\ss -> map ('1':) ss) ["0"] -- 0, 10, 110, ...
terminal_ones  = [""] : iterate (\ss -> map ('0':) ss) ["1"] -- 1, 01, 001, ... 

zero_ones = iterate (\ss -> map (consOtherDigit "0") ss) [""]
one_zeros = iterate (\ss -> map (consOtherDigit "1") ss) [""]
alternators = combineMLtests zero_ones one_zeros

zeros_or_ones = combineMLtests zeros ones
terminal_both = combineMLtests terminal_zeros terminal_ones

-- remove the first set since it includes "", a prefix to other elements
multisize :: [[String]]
multisize = drop 1 (foldr combineMLtests [[]] 
                          [terminal_ones, drop 2 terminal_zeros, 
                          drop 4 terminal_ones, drop 6 zeros])

-- Note that even though there are shared prefixes, no string in any
-- generator set is a prefix of any other (since they're all the same
-- length!).
someofem = foldr combineMLtests [[]] 
                 [zeros, ones, terminal_zeros, terminal_ones, zero_ones, 
                 one_zeros]
-- don't include e.g. multisize--you'll get prefix relations

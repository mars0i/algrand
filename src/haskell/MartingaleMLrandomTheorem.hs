import Data.List  (union, transpose) -- no longer used: isPrefixOf
import Debug.Trace (trace)
import Data.Typeable (typeOf)
-- no longer used: import Data.Char  (digitToInt)


{-

This is code to help verify/understand part of the second half of
Downey and Hirschfeldt's (2010) Theorem 6.3.4, p. 236, which is their
version of Schnorr's theorem that Martin-Löf randomness is equivalent
to randomness defined by computably enumerable martingales.  In
particular, a set of infinite sequences is Martin-Löf iff it contains
no sequences such thagt a c.e. martingale would produce infinite
profit betting on subsequent digits of such a sequence.

In particular, in the M-L random -> martingale random direction of the
proof, D&H give a method for constructing a martingale for each set in
an M-L test.  The construction starts from the fact (Proposition 2.19.2,
p. 74) that every computably enumerable set of infinite sequences can be
generated by a computably enumerable prefix-free set of finite
sequences, and then the construction specifies how to define a
martingale function d_n for each prefix-free set R_n generating one of
the sets U_n that is part of a given M-L test.

The code below constructs the values of d_n for a given R_n.  D&H's
description of d_n is terse, and I had trouble working out why d_n
really is a martingale.  This code allows me to perform the
construction, see the result, and better understand why it creates a
martingale.

-}


-- TODO: naming mixes up the initial pair lists and the ultimate (Payout, Payout) lists.
-- TODO: add docstrings
-- TODO: maybe actually define the d functions so that they can be applied to inputs.

{- |
lower_payouts :: String -> [Float]
'lower_payouts generator' returns a list of payout components for 
the length of of string 'generator'.
-}
lower_payouts :: String -> [Float]
lower_payouts generator =
    let len_s = fromIntegral (length generator) in
        map (2**) [-len_s .. -1]
        -- meaning from D&H: map ((2**) . (-len_s +)) [0 .. len_s-1]
        -- Debug.Trace.trace ("len_s = " ++ show len_s) 


{- |
   generator_payouts :: String -> [(Maybe Char, Float)]

   'generator_payouts generator' returns a list of payout components for the 
   infinite sequence generated by string 'generator'.
-}
generator_payouts :: String -> [(Maybe Char, Float)]
generator_payouts generator =
    zip ((map Just generator) ++ (repeat Nothing))
        ((lower_payouts generator) ++ (repeat 1))

generator_payouts_for_test_set test_set = map generator_payouts test_set

generator_payouts_for_test test = map generator_payouts_for_test_set test


data Payout = ZeroPayout Float | OnePayout Float  deriving (Show, Eq)

{- |
    acc_payouts :: (Maybe Char, Float) -> (Payout, Payout) -> (Payout, Payout)

    Add payout 'p' in '(Maybe Char, p)' to payouts already accumulated in 
    '(ZeroPayout p0, OnePayout p1)' for each digit '0', '1'.
    'Just i' means that payout p is to be added for instances of i
    (i.e. '0', or '1').
    'Nothing' means that payout p applies to both '0' and '1', i.e.
    it will be added both to 'ZeroPayout p0' and 'OnePayout p1'.
-}
acc_payouts ::  (Payout, Payout) -> (Maybe Char, Float) -> (Payout, Payout)
acc_payouts (ZeroPayout p0, OnePayout p1) (Just '0', p) =  (ZeroPayout (p0 + p), OnePayout p1)
acc_payouts (ZeroPayout p0, OnePayout p1) (Just '1', p) =  (ZeroPayout p0,       OnePayout (p1 + p))
acc_payouts (ZeroPayout p0, OnePayout p1) (Nothing,  p) =  (ZeroPayout (p0 + p), OnePayout (p1 + p))

-- Assumes that there is a finite number of generators for each test set; this is not required by M-L.
combine_payouts_at_index payouts_at_index =
    foldl acc_payouts (ZeroPayout 0, OnePayout 0) payouts_at_index

combine_payouts_for_test_set payouts_for_test_set =
    map combine_payouts_at_index (transpose payouts_for_test_set) -- amazingly, can transpose infinite lists

payouts_for_test test =
    map combine_payouts_for_test_set (generator_payouts_for_test test)

{- 
This is instructive:

    *Main> mps = map (map generator_payouts) multisize

    *Main> map head (mps!!0)
    [(Just '1',0.5),(Just '1',0.125),(Just '0',3.125e-2),(Just '0',7.8125e-3)]

    *Main> combine_payouts_at_index (map head (mps!!0))
    (ZeroPayout 3.90625e-2,OnePayout 0.625)

    *Main> map head (drop 1 (mps!!0))
    [(Just '1',0.125),(Just '0',3.125e-2),(Just '0',7.8125e-3)]

    *Main> combine_payouts_at_index (map head (drop 1 (mps!!0)))
    (ZeroPayout 3.90625e-2,OnePayout 0.125)

But:
    *Main> x = map combine_payouts_at_index (mps!!0)
    *Main> head x
    ^C^C^C^CInterrupted.
-}
{-

https://stackoverflow.com/questions/3643172/using-maybe-type-in-haskell:

case maybeValue of
  Just value -> ...
  Nothing    -> ...

You could use Data.Maybe.fromMaybe, which takes a Maybe a and a value to
use if it is Nothing. You could use the unsafe Data.Maybe.fromJust,
which will just crash if the value is Nothing. You likely want to keep
things in Maybe. If you wanted to add an integer in a Maybe, you could
do something like

f x = (+x) <$> Just 4

which is the same as

f x = fmap (+x) (Just 4)

f 3 will then be Just 7. 

-}

----------------------------------------------------------
-- Conveience functions for constructing M-L tests

consOtherDigit initstr [] = initstr
consOtherDigit _ (s:ss) =
    if s == '1'
       then '0':s:ss
       else '1':s:ss

combineMLtests xs []         = xs
combineMLtests [] ys         = ys

--------------------------------------------------
-- Example M-L tests

-- prefix-free generators for M-L tests for infinite zeros and infinite ones
zeros          = iterate (\ss -> map ('0':) ss) [""] -- 0, 00, 000, ...
ones           = iterate (\ss -> map ('1':) ss) [""] -- 1, 11, 111, ...
terminal_zeros = [""] : iterate (\ss -> map ('1':) ss) ["0"] -- 0, 10, 110, ...
terminal_ones  = [""] : iterate (\ss -> map ('0':) ss) ["1"] -- 1, 01, 001, ... 

zero_ones = iterate (\ss -> map (consOtherDigit "0") ss) [""]
one_zeros = iterate (\ss -> map (consOtherDigit "1") ss) [""]
alternators = combineMLtests zero_ones one_zeros

zeros_or_ones = combineMLtests zeros ones
terminal_both = combineMLtests terminal_zeros terminal_ones

-- remove the first set since it includes "", a prefix to other elements
multisize :: [[String]]
multisize = drop 1 (foldr combineMLtests [[]] 
                          [terminal_ones, drop 2 terminal_zeros, 
                          drop 4 terminal_ones, drop 6 zeros])

-- Note that even though there are shared prefixes, no string in any
-- generator set is a prefix of any other (since they're all the same
-- length!).
allofem = foldr combineMLtests [[]] 
                [zeros, ones, terminal_zeros, terminal_ones, zero_ones, 
                one_zeros]
-- don't include e.g. multisize--you'll get prefix relations

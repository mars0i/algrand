import Data.List  (union, transpose) -- isPrefixOf
import Debug.Trace (trace)
import Data.Typeable (typeOf)
-- import Data.Char  (digitToInt)


-- TODO: naming mixes up the initial pair lists and the ultimate (Payout, Payout) lists.
-- TODO: add docstrings
-- TODO: maybe actually define the d functions so that they can be applied to inputs.

{- |
   lower_payouts :: String -> [Float]

   'lower_payouts generator' returns a list of payout components for 
   the length of of string 'generator'.
-}
lower_payouts :: String -> [Float]
lower_payouts generator =
    let len_s = fromIntegral (length generator) in
        map (2**) [-len_s .. -1]
        -- meaning from D&H: map ((2**) . (-len_s +)) [0 .. len_s-1]
        -- Debug.Trace.trace ("len_s = " ++ show len_s) 


{- |
   generator_payouts :: String -> [(Maybe Char, Float)]

   'generator_payouts generator' returns a list of payout components for the 
   infinite sequence generated by string 'generator'.
-}
generator_payouts :: String -> [(Maybe Char, Float)]
generator_payouts generator =
    zip ((map Just generator) ++ (repeat Nothing))
        ((lower_payouts generator) ++ (repeat 1))

generator_payouts_for_test_set test_set = map generator_payouts test_set

generator_payouts_for_test test = map generator_payouts_for_test_set test


data Payout = ZeroPayout Float | OnePayout Float  deriving (Show, Eq)

{- |
    acc_payouts :: (Maybe Char, Float) -> (Payout, Payout) -> (Payout, Payout)

    Add payout 'p' in '(Maybe Char, p)' to payouts already accumulated in 
    '(ZeroPayout p0, OnePayout p1)' for each digit '0', '1'.
    'Just i' means that payout p is to be added for instances of i
    (i.e. '0', or '1').
    'Nothing' means that payout p applies to both '0' and '1', i.e.
    it will be added both to 'ZeroPayout p0' and 'OnePayout p1'.
-}
acc_payouts ::  (Payout, Payout) -> (Maybe Char, Float) -> (Payout, Payout)
acc_payouts (ZeroPayout p0, OnePayout p1) (Just '0', p) =  (ZeroPayout (p0 + p), OnePayout p1)
acc_payouts (ZeroPayout p0, OnePayout p1) (Just '1', p) =  (ZeroPayout p0,       OnePayout (p1 + p))
acc_payouts (ZeroPayout p0, OnePayout p1) (Nothing,  p) =  (ZeroPayout (p0 + p), OnePayout (p1 + p))

-- Assumes that there is a finite number of generators for each test set; this is not required by M-L.
combine_payouts_at_index payouts_at_index =
    foldl acc_payouts (ZeroPayout 0, OnePayout 0) payouts_at_index

combine_payouts_for_test_set payouts_for_test_set =
    map combine_payouts_at_index (transpose payouts_for_test_set) -- amazingly, can transpose infinite lists

payouts_for_test test =
    map combine_payouts_for_test_set (generator_payouts_for_test test)

{- 
This is instructive:

    *Main> mps = map (map generator_payouts) multisize

    *Main> map head (mps!!0)
    [(Just '1',0.5),(Just '1',0.125),(Just '0',3.125e-2),(Just '0',7.8125e-3)]

    *Main> combine_payouts_at_index (map head (mps!!0))
    (ZeroPayout 3.90625e-2,OnePayout 0.625)

    *Main> map head (drop 1 (mps!!0))
    [(Just '1',0.125),(Just '0',3.125e-2),(Just '0',7.8125e-3)]

    *Main> combine_payouts_at_index (map head (drop 1 (mps!!0)))
    (ZeroPayout 3.90625e-2,OnePayout 0.125)

But:
    *Main> x = map combine_payouts_at_index (mps!!0)
    *Main> head x
    ^C^C^C^CInterrupted.
-}
{-

https://stackoverflow.com/questions/3643172/using-maybe-type-in-haskell:

case maybeValue of
  Just value -> ...
  Nothing    -> ...

You could use Data.Maybe.fromMaybe, which takes a Maybe a and a value to
use if it is Nothing. You could use the unsafe Data.Maybe.fromJust,
which will just crash if the value is Nothing. You likely want to keep
things in Maybe. If you wanted to add an integer in a Maybe, you could
do something like

f x = (+x) <$> Just 4

which is the same as

f x = fmap (+x) (Just 4)

f 3 will then be Just 7. 

-}

----------------------------------------------------------
-- Conveience functions for constructing M-L tests

consOtherDigit initstr [] = initstr
consOtherDigit _ (s:ss) =
    if s == '1'
       then '0':s:ss
       else '1':s:ss

combineMLtests xs []         = xs
combineMLtests [] ys         = ys

--------------------------------------------------
-- Example M-L tests

-- prefix-free generators for M-L tests for infinite zeros and infinite ones
zeros          = iterate (\ss -> map ('0':) ss) [""] -- 0, 00, 000, ...
ones           = iterate (\ss -> map ('1':) ss) [""] -- 1, 11, 111, ...
terminal_zeros = [""] : iterate (\ss -> map ('1':) ss) ["0"] -- 0, 10, 110, ...
terminal_ones  = [""] : iterate (\ss -> map ('0':) ss) ["1"] -- 1, 01, 001, ... 

zero_ones = iterate (\ss -> map (consOtherDigit "0") ss) [""]
one_zeros = iterate (\ss -> map (consOtherDigit "1") ss) [""]
alternators = combineMLtests zero_ones one_zeros

zeros_or_ones = combineMLtests zeros ones
terminal_both = combineMLtests terminal_zeros terminal_ones

-- remove the first set since it includes "", a prefix to other elements
multisize :: [[String]]
multisize = drop 1 (foldr combineMLtests [[]] 
                          [terminal_ones, drop 2 terminal_zeros, 
                          drop 4 terminal_ones, drop 6 zeros])

-- Note that even though there are shared prefixes, no string in any
-- generator set is a prefix of any other (since they're all the same
-- length!).
allofem = foldr combineMLtests [[]] 
                [zeros, ones, terminal_zeros, terminal_ones, zero_ones, 
                one_zeros]
-- don't include e.g. multisize--you'll get prefix relations
